/* variables */
const BET_AMOUNT = 10000000000000000; /* 0,01 ether, around $6 */
let GAS = 900000;
let GAS_PRICE = 2000000000;
const bets = [];
let account;
let contract;
let lastPosition = 0;
let wheelSpinCounter = 0;
let firstBetAfterSpin = true;
let web3Provider = null;
let lastBlockEvent = 0;

const betTypes = [
  'color', 'column', 'dozen',
  'eighteen', 'modulus', 'number'
];

function showWarning(msg) {
  var p = document.getElementById('warning');
  p.innerHTML = msg;
  p.style.display = 'block';
}

function init() {
  return initWeb3();
}


async function initWeb3() {
  // Is there an injected web3 instance?
  if (typeof web3 !== 'undefined') {
    web3Provider = web3.currentProvider;
  } else {
    // If no injected web3 instance is detected, fall back to Ganache
    //web3Provider = new Web3.providers.HttpProvider('http://localhost:7545');
    web3Provider = new Web3.providers.HttpProvider('https://ropsten.infura.io/v3/f1a6a5d57420473b975975c55f5d3666');
    //web3Provider = new Web3.providers.HttpProvider('https://rpc-mumbai.matic.today');
  }
  web3 = new Web3(web3Provider);

  if (window.ethereum) {
    try {
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });

      account = accounts[0];
      console.log(account);

    } catch (error) {
      if (error.code === 4001) {
        // User rejected request
      }

      setError(error);
    }
  }

  // web3.eth.getGasPrice().then((result) => {
  //   GAS_PRICE = result * 1.5;
  // });

  initContract();

}

function initContract() {
  // get abi and deployed address
  $.getJSON('Roulette.json', (data) => {

    let address = '0x4c88Aa30965087a6792cCe2a7D0e7993840c29cA';// Ropsten
    //let address = '0x3e98C5eff32A700c43b30430c509F5Dd6AF4AD25'; //Mumbai

    // get contract instance
    const abi = data.abi;

    console.log(data);

    contract = new web3.eth.Contract(data.abi, address, {
      from: account // default from address
    });


    initEventListeners();

    getStatus();

    window.ethereum.on('accountsChanged', function (accounts) {
      // Time to reload your interface with accounts[0]!
      console.log(accounts[0]);
      account = accounts[0];
      
      getStatus();
    });

  });
}

function initEventListeners() {

  contract.events.MadeBet({}, function (err, res) {
    if (err) return void showError('Event listner error MadeBet', err);

    bet = { type: 5, value: parseInt(res.returnValues._value) , account: res.returnValues._from};

    pushBet(bet);
    
    getStatus();
    
  });

  /* listening for events from the smart contract */
  contract.events.RandomNumber({}, function (err, res) {

    if (res.blockNumber > lastBlockEvent) {               
      
      /* prevent duplicated events */
      /* 'random' number generated by the smart contract */
      const oneRandomNumber = parseInt(res.returnValues.number);
      /* increment spin counter */
      wheelSpinCounter += 1;
      /* get wheel element */
      var wheel = document.getElementById("wheel");
      /* reset wheel */
      wheel.style.transform = "rotate(" + lastPosition + "deg)";
      /* numbers in the wheel, ordered clockwise */
      var numbers = [
        0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27,
        13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1,
        20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26
      ];
      /* calculate how much do we need to rotate to have the random number chosen */
      var numberDegree = numbers.indexOf(oneRandomNumber) * 360 / numbers.length;
      /* add some rounds before to look like it's spinning */
      var numRoundsBefore = 3 * wheelSpinCounter;
      /* calculate total degrees we need to rotate */
      var totalDegrees = (numRoundsBefore * 360) + numberDegree;

      /* rotate the wheel */
      document.getElementById("wheel").style.transform = "rotate(-" + totalDegrees + "deg)";
      /* save position to be able to reset the wheel next time */
      lastPosition = numberDegree;
      /* show status on bets after wheel stops */
      setTimeout(function () {
        showBetsStatus(oneRandomNumber);
      }, 2000);
      lastBlockEvent = res.blockNumber;

      getStatus();
    }
  });
}

function showError(msg, err) {
  console.log(msg);
  console.log(err);
  const p = document.getElementById('errorPanel');
  p.innerText = msg;
  setTimeout(function () {
    p.innerHTML = '&nbsp;';
  }, 4000);
}

function hideBets() {
  var div = document.getElementById('betsList');
  while (div.firstChild) {
    div.removeChild(div.firstChild);
  }
}

function cleanBets() {
  bets.length = 0;
  hideBets();
}

function placeBet() {
  let area = this.id;
  let bet = {};
  if (/^n\d\d/.test(area)) bet = { type: 5, value: parseInt(area.substr(1)) , account: account};

  if (bet.hasOwnProperty('type') && bet.hasOwnProperty('value')) {

    contract.methods.bet(bet.value).send({ value: BET_AMOUNT }, function (err, res) {
      if (err) {
        return void showError('not enough money in the bank', err);
      }
      pushBet(bet);
    });

    getStatus();
  }
}

function pushBet(hash) {

  if (firstBetAfterSpin) {
    cleanBets();
  }

  firstBetAfterSpin = false;
  
  bets.push(hash);

  printBet(hash);

}

function printBet(hash) {

  const value = hash.value ;
  const address = hash.account ;
  const div = document.getElementById('betsList');
  const p = document.createElement('p');
  p.innerText = 'Address '+address + ' Number: ' + value + '';

  if (hash.hasOwnProperty('status')) {
    p.innerText += (hash.status ? 'WIN' : 'LOST');
  }

  div.appendChild(p);
}

function showBetsStatus(num) {
  hideBets();
  bets.map(function (bet) {
    printBet(bet);
  })
}

function spinWheel() {
  contract.methods.spinWheel().send({ from: account, value: 0, gas: GAS, gasPrice: GAS_PRICE }, function (err, res) {
    if (err) return void showError('to soon to play?', err);
    firstBetAfterSpin = true;
  });
}

function toEther(bigNum) {
  return (bigNum / 1000000000000000000).toFixed(2)
}

function updateHTML(value, elId) {
  const span = document.getElementById(elId);
  span.innerText = value;
}

/* call smart contract to get status and update UI */
function getStatus() {

  contract.methods.getStatus().call(function (error, result) {

    if (error) return void showError('something went wrong with getStatus', error);

    updateHTML(result[0], 'betsCount');                             // bets count
    result[1] = toEther(result[1]);                                   // bets value
    updateHTML(result[1], 'betsValue');
    const now = Math.round(new Date() / 1000);                  // time until next spin

    updateHTML(result[2], 'timeUntilNextSpin');
    result[3] = toEther(result[3]);                                   // roulette balance
    updateHTML(result[3], 'balance');
    result[4] = toEther(result[4]);                                   // winnings
    updateHTML(result[4], 'winnings');

    web3.eth.getBalance(account, function (error, balance) {  // player balance
      balance = toEther(balance);
      updateHTML(balance, 'yourBalance');
    });

    let allBets = result[5];
    cleanBets();

    allBets.forEach(function(element) {

      //console.log(element);

      bet = { type: 5, value: parseInt(element.number), account: element.player };

      pushBet(bet);
    });

  });
}

document.addEventListener('DOMContentLoaded', function () {
  /* adds click event to roulette table */
  var areas = document.getElementsByTagName('area');
  for (i = 0; i < areas.length; i++) {
    areas[i].onclick = placeBet;
  };
  init();
})
